# 01.00 - State Management

## Addresses

Managing state - data in memory - of this Angular appplication.

## Challenges

- *Change Detection*
  - As data in memory changes that data is usually projected into the HTML displayed to the user (in a component), or
  - Impacts other parts of our application that need to react to changes in that state.
  - This is not an "automatic feature" of web applications. The DOM provides an API for changing the content of elements programaticaly, but does *not* have any facility for referencing our data and keeping the DOM (and the UI) in sync with that data.


## History

Just within Angular there have been a variety of ways to address this problem, particularly with components.

Angular.JS - and therefore Angular (2+) had what *appeared* to be "automatic change detection". This is one of the reasons for it's popularity. The requirements for keeping the UI in sync with the data in our application were pretty simple:

- Define your data as part of the component class.
- Use various techniques to "bind" that data to the template (binding expressions, `ngModel`, etc.)
- On interactions with the UI, Angular would "invisibly" compare it's idea of what should be in the DOM with the state in the components, and, if needed update either the state or the component's data.
- Sort of like a "helicopter parent" - every time you do something, "mommy" would come in the room and clean up after you.

This works really well, and has served us reliably for many years. It is not without it's problems, though:

- It can be slow.
- Sometimes you might need to use "advanced" techniques to tell "mom" to come in and clean up.

The biggest issue is reliably telling "mom" (the change detection) *when* it should clean up.

The change detection knows to run when there are explicit interactions from the user with the DOM.

- The user clicks a button, fills out a form, etc.

However, some interactions with the state of our application are not the result of user interactions - they sort of come in through the back door.

- Asynchonrous operations, like API calls, eventually return data (or errors) that we programatically handle and update the state.
- Various "watchers" we create - like geolocation, timers, etc. may trigger state changes.

The way Angular has handled this is to have the change detection secretly replace all the ways it predicts these "kitchen door" state changes can happen with imposters that look like the "kitchen door", but have little alarms on them that only change detection can hear.

This is accomplished by Angular loading a [Polyfill](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) called `zone.js`.

> Note: Zone.js does more than what I'm talking about here, but this is the important part for us. It's actually pretty cool.

### Problems with Zone.Js

There are several issues that have arisen with the use of Zone.JS over the years. It started, like many things in programming, as a useful abstraction, but eventually it outlived it's usefulness.

- It required the maintainers of Zone.js the constantly predict all the ways browsers will evolve to allow additional asynchronous operations and try to handle those.
- When it didn't or couldn't, the developer had to resort to lower level techniques to "summon" change detection.
- As a polyfill, it could only change browser APIs, but it couldn't handle features related to changes in JavaScript itself. A notable example is the addition of `async/await` keywords for promises ("thenables") in JavaScript. Zone.JS can't do anything with this.
  - Side note - You might notice most Angular apps don't use `async/await`. This is partially because Angular early one leaned into Observables as *the* pattern for asynchroncity in Angular instead of promises. But it's also the fact that for quite a while, you *couldn't* use async/await because it created a "gap" that zone.js couldn't handle.
  - That is still true - zone.js can't deal with `async/await`, so, as we do as developers, we added another "hack" so that we could use it. The Angular compiler (NGC) will convert any use of `async/await` in your code to JavaScript [generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
  - This means we are getting farther from the code we've written to the code that is running in the browser - which can be a headache.
- Probably the biggest thing that has caused the crisis in moving away from zone.js, though, is that it replaces browser APIs, and those don't exist at the server. So if you want to generate your code at the server side (SSR/SSG) zone.js is a no-go.

### The *Real* Problem

We've come to see the metaphor for change detection was off. Maybe we shouldn't rely on an "all powerful" "Mom" or "Dad" to handle that stuff for us. While we certainly don't want to drudgery (and bug ridden) way of doing DOM updates manually, a lower-level approach might be better. 

Make your toys clean up after themselves.

### Enter Signals

The idea behind Signals is that they are objects that hold some data, and they know how to track changes themselves - as well as telling the UI when it's time to update. 

Read about [Signals Here](./01.01-signals.md)

### Observables

The RXJS Library for Observables is not an "Angular" thing. It is a 3rd party dependency maintained outside of Angular. It is a *powerful* library for working with streams of things that happen over time.

Angular's early embrace of Observables was arguably a good choice. They can do *everything*. However, that means they are also quite complicated, even when the problem you are trying to address isn't that complicated.

They can feel a bit like using a chainsaw to butter your bread sometimes - when a butter knife would do. But sometimes you need the chainsaw. You wouldn't want to cut down a tree with a butter knife. But when your only tool is a chainsaw? You have to be very careful when spreading jam.

Observables really shine in Angular in some places (dealing with parallel streams of things and projecting results based on that, for example). But with the introduction of Signals, a lof of their use is now overkill. Leave the chainsaw in the garage for when you need it.

